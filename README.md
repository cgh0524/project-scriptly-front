# Scriptly - ë¸”ë¡ ê¸°ë°˜ ë§ˆí¬ë‹¤ìš´ ì—ë””í„°

> ì‹¤ë¬´ ê²½í—˜ì„ ë°”íƒ•ìœ¼ë¡œ í”„ë¡ íŠ¸ì—”ë“œ íŠ¹í™” ì•„í‚¤í…ì²˜ë¥¼ í•™ìŠµí•˜ê³  ì ìš©í•œ ë©”ëª¨ ë„êµ¬

ğŸ”— **Live Demo**: [ë°°í¬ ë§í¬](https://cgh0524.github.io/project-scriptly-front)

## ğŸš€ ì£¼ìš” ì„±ì·¨

### í•µì‹¬ ì„±ê³¼

- **ì•„í‚¤í…ì²˜ ê°œì„ **: í´ë¦° ì•„í‚¤í…ì²˜ì˜ í•œê³„ë¥¼ ë¶„ì„í•˜ê³  FSD ì•„í‚¤í…ì²˜ í•™ìŠµ ì ìš©
- **í™•ì¥ ê°€ëŠ¥í•œ ì„¤ê³„**: Repository íŒ¨í„´ìœ¼ë¡œ IndexedDB â†’ REST API ë§ˆì´ê·¸ë ˆì´ì…˜ ëŒ€ë¹„
- **ì»¤ìŠ¤í…€ ì—ë””í„°**: Selection API í™œìš©í•œ ë¸”ë¡ ê¸°ë°˜ ì‹¤ì‹œê°„ ë§ˆí¬ë‹¤ìš´ ë Œë”ë§

## ğŸ—ï¸ ì•„í‚¤í…ì²˜ ì„ íƒ ê³¼ì •

### ë¬¸ì œ ì¸ì‹: í´ë¦° ì•„í‚¤í…ì²˜ì˜ í”„ë¡ íŠ¸ì—”ë“œ ì ìš© í•œê³„

ì‹¤ë¬´ì—ì„œ í´ë¦° ì•„í‚¤í…ì²˜ë¥¼ ì‚¬ìš©í•˜ë©° ê²½í—˜í•œ ì–´ë ¤ì›€ë“¤:

- ì‹¤ë¬´ì—ì„œëŠ” ì™¸ë¶€ ê¸°ìˆ ë³´ë‹¤ **ë‚´ë¶€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ ë” ìì£¼ ë³€ê²½**
- UI ì»´í¬ë„ŒíŠ¸ ì„¤ê³„ ê¸°ì¤€ ë¶€ì¬ë¡œ ì¸í•œ **ê±°ëŒ€ ì»´í¬ë„ŒíŠ¸ì™€ ë¡œì§ ê°•ê²°í•©**
- ê³¼ë„í•œ ì¶”ìƒí™”ë¡œ ì¸í•œ **ê°œë°œ ë³µì¡ì„± ì¦ê°€**

### í•´ê²° ë°©ì•ˆ: Feature Sliced Design ë„ì…

**ì„ íƒ ê·¼ê±°**:

- í”„ë¡ íŠ¸ì—”ë“œì— íŠ¹í™”ëœ ì•„í‚¤í…ì²˜ë¡œ UI ê³„ì¸µ ì²´ê³„í™”
- ê¸°ëŠ¥ ì¤‘ì‹¬ êµ¬ì¡°ë¡œ ë†’ì€ ì½”ë“œ ì‘ì§‘ë„ í™•ë³´
- ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ìµœì†Œí™”ë¡œ ì‹¤ìš©ì  ê°œë°œ í™˜ê²½ êµ¬ì¶•

**ë„ì… ê²°ê³¼**:

- ì‘ì—… íš¨ìœ¨ì„± í–¥ìƒ (ì½”ë“œ ìœ„ì¹˜ íŒŒì•… ìš©ì´)
- ìœ ì§€ë³´ìˆ˜ì„± ê°œì„  (ê¸°ëŠ¥ë³„ ë…ë¦½ì  ê´€ë¦¬)
- í™•ì¥ì„± í™•ë³´ (MVP â†’ ê³ ë„í™” ìì—°ìŠ¤ëŸ¬ìš´ ì „í™˜)

### ì‹¤ë¬´ ì ìš© ì¸ì‚¬ì´íŠ¸

- **Repository íŒ¨í„´**: ë°ì´í„° ì¶”ìƒí™”ì˜ ì¥ì ì€ ìœ ì§€í•˜ë˜ FSD êµ¬ì¡° ë‚´ì—ì„œ ì ìš©
- **ê¸°ëŠ¥ ì¤‘ì‹¬ í´ë”ë§**: "ì–´ëŠ í´ë”ì— ë„£ì„ê¹Œ?" ê³ ë¯¼ ì‹œê°„ ëŒ€í­ ë‹¨ì¶•
- **ì ì§„ì  ê°œë°œ**: MVPë¶€í„° ë³µì¡í•œ ê¸°ëŠ¥ê¹Œì§€ ìì—°ìŠ¤ëŸ¬ìš´ í™•ì¥ ê²½ë¡œ í™•ë³´

## ğŸ’¡ í•µì‹¬ ê¸°ìˆ  êµ¬í˜„

### 1. í™•ì¥ ê°€ëŠ¥í•œ ë°ì´í„° ë ˆì´ì–´ ì„¤ê³„

**ë¬¸ì œ**: IndexedDB â†’ REST API ì „í™˜ ì‹œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë³€ê²½ ìµœì†Œí™” í•„ìš”

**í•´ê²°**: Repository íŒ¨í„´ìœ¼ë¡œ ë°ì´í„° ì†ŒìŠ¤ ì¶”ìƒí™”

```typescript
// ê³µí†µ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
interface MemoRepository {
  findAll(): Promise<Memo[]>;
  findById(id: string): Promise<Memo | null>;
  create(memo: CreateMemoRequest): Promise<Memo>;
  update(id: string, memo: UpdateMemoRequest): Promise<Memo>;
  delete(id: string): Promise<void>;
}

// IndexedDB êµ¬í˜„ì²´
class IdbMemoRepository implements MemoRepository { ... }

// REST API êµ¬í˜„ì²´ (í–¥í›„ êµ¬í˜„)
class HttpMemoRepository implements MemoRepository { ... }

// ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ì¼ê´€ëœ ì¸ìŠ¤í„´ìŠ¤ ì œê³µ
export const memoRepository = new IdbMemoRepository();
```

### 2. ë¸”ë¡ ê¸°ë°˜ ì—ë””í„° ì•„í‚¤í…ì²˜

**ë¬¸ì œ**: ê¸°ì¡´ textareaë¡œëŠ” ë¸”ë¡ ë‹¨ìœ„ ì¡°ì‘ ë¶ˆê°€

**í•´ê²°**: Selection API + ì»¤ìŠ¤í…€ ë¸”ë¡ ì‹œìŠ¤í…œ

```typescript
// ë¸”ë¡ì— í¬ì»¤ìŠ¤ ì„¤ì • ë° ì»¤ì„œ ìœ„ì¹˜ ì œì–´
export const focusBlock = (blockId: string, cursorOffset?: number): void => {
  const blockElement = getBlockElement(blockId);
  if (!blockElement) return;

  blockElement.focus();

  if (cursorOffset === undefined) return;

  // Selection APIë¡œ ì •í™•í•œ ì»¤ì„œ ìœ„ì¹˜ ì„¤ì •
  const selection = window.getSelection();
  const range = document.createRange();

  const textNode = blockElement.firstChild;
  if (textNode && textNode.nodeType === Node.TEXT_NODE) {
    const maxOffset = Math.min(cursorOffset, textNode.textContent?.length || 0);
    range.setStart(textNode, maxOffset);
    range.setEnd(textNode, maxOffset);

    selection?.removeAllRanges();
    selection?.addRange(range);
  }
};

// ì»¤ì„œ ìœ„ì¹˜ì—ì„œ HTMLì„ ì•/ë’¤ë¡œ ë¶„í•  (ì—”í„°í‚¤ ì²˜ë¦¬ìš©)
export const splitHtmlAtCursor = (element: HTMLElement) => {
  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0) {
    return { beforeHtml: element.innerHTML || '', afterHtml: '' };
  }

  const range = selection.getRangeAt(0);
  // ... HTML êµ¬ì¡°ë¥¼ ìœ ì§€í•˜ë©° ë¶„í•  ë¡œì§
};
```

### 3. ì‹¤ì‹œê°„ ë§ˆí¬ë‹¤ìš´ ë Œë”ë§

**ë¬¸ì œ**: ì…ë ¥ê³¼ ë™ì‹œì— ë§ˆí¬ë‹¤ìš´ ë¬¸ë²•ì„ ì‹œê°ì ìœ¼ë¡œ ë Œë”ë§ í•„ìš”

**í•´ê²°**: í™•ì¥ ê°€ëŠ¥í•œ íŒ¨í„´ ê¸°ë°˜ íŒŒì„œ + ìŠ¤í˜ì´ìŠ¤ë°” íŠ¸ë¦¬ê±°

```typescript
// í™•ì¥ ê°€ëŠ¥í•œ ë§ˆí¬ë‹¤ìš´ íŒ¨í„´ ì •ì˜
interface MarkdownPattern {
  name: string;
  pattern: RegExp;
  trigger: string;
  transform: (match: RegExpMatchArray) => { tagName: string; content: string };
}

const PATTERNS: MarkdownPattern[] = [
  {
    name: 'heading',
    pattern: /^(#{1,6})\s*(.*)$/,
    trigger: ' ',
    transform: (match) => {
      const [, hashes, content] = match;
      const level = hashes.length;
      return { tagName: `h${level}`, content: content.trim() };
    },
  },
  // TODO: ë¦¬ìŠ¤íŠ¸, ì¸ìš©êµ¬ ë“± ì¶”ê°€ íŒ¨í„´ í™•ì¥ ì˜ˆì •
];

// íŒ¨í„´ ê°ì§€ í•¨ìˆ˜
export const detectMarkdownPattern = (text: string, trigger: string = ' ') => {
  for (const pattern of PATTERNS) {
    if (pattern.trigger !== trigger) continue;

    const match = text.match(pattern.pattern);
    if (match) {
      const result = pattern.transform(match);
      return { type: pattern.name, ...result };
    }
  }
  return null;
};

// í‚¤ë³´ë“œ ì´ë²¤íŠ¸ì—ì„œ ì‹¤ì‹œê°„ ë³€í™˜ ì²˜ë¦¬
const handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {
  if (event.key === ' ') {
    const element = event.currentTarget;
    const text = element.textContent || '';

    const pattern = detectMarkdownPattern(text);
    if (pattern) {
      event.preventDefault();
      const cursorOffset = pattern.content.length;
      onTransform?.(block.id, pattern.tagName, pattern.content, cursorOffset);
    }
  }
};
```

### 4. IndexedDB Promise ë˜í•‘

**ë¬¸ì œ**: IndexedDBì˜ ì´ë²¤íŠ¸ ê¸°ë°˜ APIë¡œ ì¸í•œ ì½œë°± í—¬ê³¼ ë³µì¡í•œ ì—ëŸ¬ ì²˜ë¦¬

**í•´ê²°**: Promise ê¸°ë°˜ íŠ¸ëœì­ì…˜ ë˜í¼ë¡œ ë¹„ë™ê¸° ì²˜ë¦¬ ê°œì„ 

```typescript
// íŠ¸ëœì­ì…˜ í—¬í¼ í•¨ìˆ˜ - ì´ë²¤íŠ¸ë¥¼ Promiseë¡œ ë˜í•‘
export async function executeTransaction<T>(
  db: IDBDatabase,
  storeName: string,
  mode: IDBTransactionMode = 'readonly',
  work: (store: IDBObjectStore) => Promise<T | undefined>,
): Promise<T | undefined> {
  const store = db.transaction([storeName], mode).objectStore(storeName);
  const result = await work(store);
  return result;
}

// Repositoryì—ì„œ Promise íŒ¨í„´ í™œìš©
const createMemo = async (memo: CreateMemoRequest): Promise<Memo> => {
  const idbMemo = await executeTransaction<IdbMemo>(db, 'memos', 'readwrite', async (store) => {
    const newIdbMemo = toIdb(memo);

    // ì´ë²¤íŠ¸ ê¸°ë°˜ APIë¥¼ Promiseë¡œ ë³€í™˜
    await new Promise<void>((resolve, reject) => {
      const req = store.add(newIdbMemo);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });

    return newIdbMemo;
  });

  if (!idbMemo) {
    throw new Error('Failed to create memo');
  }
  return toDomain(idbMemo);
};
```

## ğŸš€ ì£¼ìš” ê¸°ëŠ¥

### í˜„ì¬ êµ¬í˜„ëœ ê¸°ëŠ¥

- **ë¸”ë¡ ê¸°ë°˜ ì‹¤ì‹œê°„ ë§ˆí¬ë‹¤ìš´ ë Œë”ë§**: Heading ë¬¸ë²• ì§€ì› (# ~ ######)
- **ë°©í–¥í‚¤ ë„¤ë¹„ê²Œì´ì…˜**: í™”ì‚´í‘œ í‚¤ë¥¼ í†µí•œ ì§ê´€ì ì¸ ë¸”ë¡ ê°„ ì´ë™
- **Repository íŒ¨í„´**: IndexedDB ê¸°ë°˜ ë©”ëª¨ CRUD êµ¬í˜„

### ğŸ“ˆ ì„±ëŠ¥ ìµœì í™” ë° í™•ì¥ ê³„íš

- **ë§ˆí¬ë‹¤ìš´ ë¬¸ë²• í™•ì¥**: ë¦¬ìŠ¤íŠ¸, ê°•ì¡° í‘œì‹œ ë“± ì¸ë¼ì¸ ë¬¸ë²• ì§€ì›
- **ê°€ìƒ ìŠ¤í¬ë¡¤ë§**: ëŒ€ëŸ‰ ë©”ëª¨ ë°ì´í„° ìµœì í™”
- **REST API ì—°ë™**: ë°±ì—”ë“œ ì„œë²„ì™€ì˜ ë°ì´í„° ë™ê¸°í™”

## ğŸ› ï¸ ê¸°ìˆ  ìŠ¤íƒ

| ë¶„ì•¼                 | ê¸°ìˆ                         |
| -------------------- | --------------------------- |
| **Framework**        | React 18 + TypeScript       |
| **Build Tool**       | Vite                        |
| **Styling**          | styled-components           |
| **State Management** | Jotai                       |
| **Local Storage**    | IndexedDB                   |
| **Architecture**     | Feature-Sliced Design (FSD) |

## âš¡ Quick Start

```bash
# í”„ë¡œì íŠ¸ í´ë¡ 
git clone [repository-url]

# ì˜ì¡´ì„± ì„¤ì¹˜
yarn install

# ê°œë°œ ì„œë²„ ì‹¤í–‰
yarn dev
```
